<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>AI Village (v1) — Viewer</title>
  <style>
    :root { --bg: #f5f5f5; --panel: #fff; --border: #ccc; }
    html, body { height: 100%; }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #topbar {
      padding: 12px 14px 10px 14px;
      border-bottom: 1px solid #e3e3e3;
      background: rgba(245,245,245,0.92);
      backdrop-filter: blur(8px);
    }
    #topbar h2 { margin: 0 0 8px 0; font-size: 20px; }
    #statusLine { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; font-size: 13px; }
    #statusLine .kv { display: inline-flex; gap: 6px; align-items: center; }
    #desc { margin: 8px 0 0 0; color: #333; max-width: 1100px; font-size: 13px; }

    .layout {
      flex: 1;
      min-height: 0;
      display: grid;
      grid-template-columns: minmax(560px, 1fr) minmax(360px, 520px);
      gap: 12px;
      padding: 12px;
    }
    #canvasWrap {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
    }
    canvas { background: white; border: 1px solid #ddd; border-radius: 8px; display: block; }

    #sidebar {
      min-height: 0;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #sidebar > * { width: 100% !important; box-sizing: border-box; }
    #log {
      background: white;
      border: 1px solid #ccc;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 6px;
      min-height: 120px;
      max-height: 220px;
    }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eee; }
    .ok { background: #d4edda; }
    .bad { background: #f8d7da; }
    #tooltip {
      position: fixed;
      display: none;
      z-index: 9999;
      max-width: 360px;
      background: rgba(20, 20, 20, 0.92);
      color: #fff;
      padding: 8px 10px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      pointer-events: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <header id="topbar">
    <h2>AI Village (v1) — World Viewer</h2>
    <div id="statusLine">
      <span class="kv"><span>WebSocket:</span><span id="wsStatus" class="pill bad">disconnected</span></span>
      <span class="kv"><span>World:</span><span id="worldStatus" class="pill">tick=? agents=?</span></span>
      <span class="kv"><span>Time:</span><span id="timeStatus" class="pill">day=? ??:??</span></span>
      <span class="kv"><span>Topic:</span><span id="topicStatus" class="pill">loading…</span></span>
      <span class="kv"><span>Balances:</span><span id="balancesStatus" class="pill">loading…</span></span>
      <span class="kv"><span>Run:</span><span id="runStatus" class="pill">loading…</span></span>
    </div>
    <p id="desc">
      Served by the backend. Live world via <code>/ws/world</code>. Use “Run Controls” to start new runs and view results.
    </p>
  </header>

  <div class="layout">
    <div id="canvasWrap">
      <canvas id="world" width="640" height="640"></canvas>
    </div>
    <div id="sidebar">
      <div style="background:white; border:1px solid #ccc; padding:10px; border-radius:6px; width:420px;">
        <h3 style="margin:0 0 8px 0;">Run Controls</h3>
        <div style="display:flex; gap:8px; margin-bottom:8px; align-items:center;">
          <input id="adminToken" type="password" placeholder="ADMIN_TOKEN (optional)" style="padding:6px; flex:1;" />
          <button id="newRunBtn">Start New Run</button>
        </div>
        <div style="display:flex; gap:12px; margin-bottom:8px; font-size:12px; color:#444;">
          <label style="display:flex; gap:6px; align-items:center;"><input id="resetTopicChk" type="checkbox" checked />reset topic</label>
          <label style="display:flex; gap:6px; align-items:center;"><input id="resetBoardChk" type="checkbox" />reset board</label>
        </div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
          <button id="runsRefreshBtn">Refresh Runs</button>
          <select id="runsSelect" style="padding:6px; flex:1;"></select>
          <button id="openViewerBtn">Open Viewer</button>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <button id="loadSummaryBtn">Load Summary</button>
          <span id="runsStatus" class="pill">?</span>
        </div>
        <pre id="runSummary" style="white-space:pre-wrap; background:#fafafa; border:1px solid #ddd; padding:8px; border-radius:6px; max-height:220px; overflow:auto; font-size:12px;"></pre>
      </div>
      <div id="log"></div>

      <div style="background:white; border:1px solid #ccc; padding:10px; border-radius:6px; width:420px;">
        <h3 style="margin:0 0 8px 0;">Agent Trace (thoughts/actions)</h3>
        <div id="traceLog" style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:12px; max-height:220px; overflow-y:auto;"></div>
      </div>

      <div style="background:white; border:1px solid #ccc; padding:10px; border-radius:6px; width:420px;">
        <h3 style="margin:0 0 8px 0;">Bulletin Board</h3>
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <button id="refreshPostsBtn">Refresh</button>
          <span id="boardStatus" class="pill bad">unknown</span>
        </div>

        <div style="display:flex; flex-direction:column; gap:6px;">
          <input id="postTitle" type="text" placeholder="Post title" style="padding:6px;" />
          <textarea id="postBody" placeholder="Write a post..." rows="3" style="padding:6px;"></textarea>
          <div style="display:flex; gap:8px;">
            <input id="postAuthor" type="text" placeholder="author_id (optional)" style="padding:6px; flex:1;" />
            <button id="createPostBtn">Create Post</button>
          </div>
        </div>

        <hr style="margin:12px 0;" />

        <div style="display:flex; gap:8px;">
          <select id="postsSelect" style="padding:6px; flex:1;"></select>
          <button id="loadPostBtn">Load</button>
        </div>

        <div id="postDetails" style="margin-top:10px; font-size: 13px;"></div>

        <div style="margin-top:8px;">
          <textarea id="replyBody" placeholder="Reply..." rows="2" style="padding:6px; width:100%;"></textarea>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <input id="replyAuthor" type="text" value="human" style="padding:6px; flex:1;" />
            <button id="replyBtn">Reply</button>
          </div>
        </div>
      </div>

      <div style="background:white; border:1px solid #ccc; padding:10px; border-radius:6px; width:420px;">
        <h3 style="margin:0 0 8px 0;">Jobs (earn ai$)</h3>
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <input id="jobTitle" type="text" placeholder="Job title" style="padding:6px; flex:1;" />
          <input id="jobReward" type="number" value="10" min="0" step="1" style="padding:6px; width:110px;" />
        </div>
        <textarea id="jobBody" placeholder="What should the agent deliver? (be specific)" rows="3" style="padding:6px; width:100%;"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
          <input id="jobReviewer" type="text" value="human" style="padding:6px; flex:1;" />
          <button id="jobCreateBtn">Create Job</button>
          <button id="jobsRefreshBtn">Refresh</button>
        </div>
        <div id="jobsList" style="margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:12px; max-height:260px; overflow-y:auto;"></div>
      </div>

      <div style="background:white; border:1px solid #ccc; padding:10px; border-radius:6px; width:420px;">
        <h3 style="margin:0 0 8px 0;">Events (invitations, parties, etc.)</h3>
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <button id="eventsRefreshBtn">Refresh</button>
          <span id="eventsStatus" class="pill">?</span>
          <label style="margin-left:auto; font-size:12px; color:#444; display:flex; align-items:center; gap:6px;">
            <input id="eventsShowPast" type="checkbox" />
            show past
          </label>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:6px;">
          <input id="eventTitle" type="text" placeholder="Event title" style="padding:6px; flex:1;" />
          <select id="eventLocation" style="padding:6px; width:140px;">
            <option value="cafe">cafe</option>
            <option value="market">market</option>
            <option value="board">board</option>
            <option value="computer">computer</option>
          </select>
        </div>
        <textarea id="eventDesc" placeholder="Description (optional)" rows="2" style="padding:6px; width:100%;"></textarea>
        <div style="display:flex; gap:8px; margin-top:6px;">
          <input id="eventStartIn" type="number" value="60" min="5" step="5" style="padding:6px; width:120px;" />
          <input id="eventDuration" type="number" value="60" min="10" step="10" style="padding:6px; width:120px;" />
          <button id="eventCreateBtn">Create</button>
        </div>
        <div id="eventsList" style="margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:12px; max-height:220px; overflow-y:auto;"></div>
      </div>
    </div>
  </div>

  <script>
    const BACKEND_WS = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/world";
    const BACKEND_HTTP = location.origin;

    const canvas = document.getElementById("world");
    const ctx = canvas.getContext("2d");
    const logBox = document.getElementById("log");
    const traceLog = document.getElementById("traceLog");
    const wsStatus = document.getElementById("wsStatus");
    const worldStatus = document.getElementById("worldStatus");
    const timeStatus = document.getElementById("timeStatus");
    const topicStatus = document.getElementById("topicStatus");
    const balancesStatus = document.getElementById("balancesStatus");
    const runStatus = document.getElementById("runStatus");

    const adminToken = document.getElementById("adminToken");
    const newRunBtn = document.getElementById("newRunBtn");
    const resetTopicChk = document.getElementById("resetTopicChk");
    const resetBoardChk = document.getElementById("resetBoardChk");
    const runsRefreshBtn = document.getElementById("runsRefreshBtn");
    const runsSelect = document.getElementById("runsSelect");
    const openViewerBtn = document.getElementById("openViewerBtn");
    const loadSummaryBtn = document.getElementById("loadSummaryBtn");
    const runsStatus = document.getElementById("runsStatus");
    const runSummary = document.getElementById("runSummary");

    function authHeaders() {
      const tok = (adminToken.value || localStorage.getItem("adminToken") || "").trim();
      if (tok) {
        localStorage.setItem("adminToken", tok);
        return { "Authorization": `Bearer ${tok}` };
      }
      return {};
    }

    async function fetchRunInfo() {
      try {
        const r = await fetch(`${BACKEND_HTTP}/run`);
        const j = await r.json();
        runStatus.textContent = j.run_id ? j.run_id : "unknown";
      } catch (e) {
        runStatus.textContent = "error";
      }
    }

    async function refreshRuns() {
      runsStatus.textContent = "loading…";
      try {
        const r = await fetch(`${BACKEND_HTTP}/runs?limit=50`);
        const j = await r.json();
        const runs = j.runs || [];
        runsSelect.innerHTML = "";
        for (const it of runs) {
          const opt = document.createElement("option");
          opt.value = it.run_id;
          const meta = it.meta || {};
          const ended = meta.ended_at ? new Date(meta.ended_at * 1000).toLocaleString() : "";
          opt.textContent = ended ? `${it.run_id} (ended ${ended})` : it.run_id;
          runsSelect.appendChild(opt);
        }
        runsStatus.textContent = `runs=${runs.length}`;
      } catch (e) {
        runsStatus.textContent = "error";
      }
    }

    async function loadSelectedSummary() {
      const rid = runsSelect.value;
      if (!rid) return;
      runsStatus.textContent = "loading…";
      runSummary.textContent = "";
      try {
        const r = await fetch(`${BACKEND_HTTP}/runs/${encodeURIComponent(rid)}/summary`);
        const j = await r.json();
        runSummary.textContent = JSON.stringify(j, null, 2);
        runsStatus.textContent = `tasks done=${(j.tasks && j.tasks.done) || 0}/${(j.tasks && j.tasks.total) || 0}`;
      } catch (e) {
        runsStatus.textContent = "error";
      }
    }

    newRunBtn.addEventListener("click", async () => {
      newRunBtn.disabled = true;
      try {
        const payload = {
          reset_topic: !!resetTopicChk.checked,
          reset_board: !!resetBoardChk.checked
        };
        const r = await fetch(`${BACKEND_HTTP}/admin/new_run`, {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify(payload),
        });
        const j = await r.json();
        if (!j.ok) {
          runsStatus.textContent = `new_run failed: ${j.error || "unknown"}`;
        } else {
          runsStatus.textContent = `started ${j.run_id}`;
          await fetchRunInfo();
          await refreshRuns();
        }
      } catch (e) {
        runsStatus.textContent = "new_run error";
      } finally {
        newRunBtn.disabled = false;
      }
    });

    runsRefreshBtn.addEventListener("click", refreshRuns);
    loadSummaryBtn.addEventListener("click", loadSelectedSummary);
    openViewerBtn.addEventListener("click", () => {
      const rid = runsSelect.value;
      if (!rid) return;
      window.open(`${BACKEND_HTTP}/runs/${encodeURIComponent(rid)}/viewer`, "_blank");
    });
    function fmtTime(day, minuteOfDay) {
      const mm = Math.max(0, minuteOfDay|0);
      const h = Math.floor(mm / 60);
      const m = mm % 60;
      const hh = String(h).padStart(2, "0");
      const mi = String(m).padStart(2, "0");
      return `day=${day} ${hh}:${mi}`;
    }

    const WORLD_SIZE = 32;
    let tile = 20;
    let worldPx = WORLD_SIZE * tile;
    const trails = {}; // agent_id -> [{x,y,ts}]
    const lastIntent = {}; // agent_id -> string (latest trace summary)
    const TRAIL_MAX = 80;
    let latestBalances = {}; // agent_id -> number
    let latestWorld = null; // last world_state payload
    const tooltip = document.createElement("div");
    tooltip.id = "tooltip";
    document.body.appendChild(tooltip);
    let lastHoverKey = "";

    function resizeCanvas() {
      const wrap = document.getElementById("canvasWrap");
      if (!wrap) return;
      const rect = wrap.getBoundingClientRect();
      // Keep a bit of padding headroom
      const maxSize = Math.floor(Math.min(rect.width - 24, rect.height - 24));
      const cssSize = Math.max(360, maxSize);
      tile = Math.max(10, Math.floor(cssSize / WORLD_SIZE));
      worldPx = tile * WORLD_SIZE;

      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = worldPx + "px";
      canvas.style.height = worldPx + "px";
      canvas.width = Math.floor(worldPx * dpr);
      canvas.height = Math.floor(worldPx * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // redraw using current state
      if (latestWorld) {
        try { renderWorld(latestWorld); } catch (e) { drawGrid(); }
      } else {
        drawGrid();
      }
    }

    let _resizeT = null;
    window.addEventListener("resize", () => {
      if (_resizeT) clearTimeout(_resizeT);
      _resizeT = setTimeout(resizeCanvas, 80);
    });

    function log(msg) {
      const line = document.createElement("div");
      line.textContent = msg;
      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function trace(msg) {
      const line = document.createElement("div");
      line.textContent = msg;
      traceLog.appendChild(line);
      traceLog.scrollTop = traceLog.scrollHeight;
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#eee";
      for (let x = 0; x <= worldPx; x += tile) {
        for (let y = 0; y <= worldPx; y += tile) {
          ctx.strokeRect(x, y, tile, tile);
        }
      }
    }

    function drawLandmarks(landmarks) {
      for (const lm of (landmarks || [])) {
        if (lm.type === "computer_access") {
          ctx.fillStyle = "#6a1b9a"; // purple
        } else {
          ctx.fillStyle = "#222";
        }
        ctx.fillRect(lm.x * tile, lm.y * tile, tile, tile);
        ctx.fillStyle = "#fff";
        ctx.font = "10px Arial";
        ctx.fillText(lm.id.slice(0, 3), lm.x * tile + 2, lm.y * tile + 12);
      }
    }

    function pushTrail(a) {
      const id = a.agent_id;
      if (!id) return;
      const arr = trails[id] || [];
      const last = arr.length ? arr[arr.length - 1] : null;
      const x = a.x, y = a.y;
      if (!last || last.x !== x || last.y !== y) {
        arr.push({x, y, ts: Date.now()});
        while (arr.length > TRAIL_MAX) arr.shift();
        trails[id] = arr;
      }
    }

    function drawTrails(agents) {
      for (const a of (agents || [])) {
        const id = a.agent_id;
        const arr = trails[id] || [];
        if (arr.length < 2) continue;
        ctx.strokeStyle = "rgba(0,0,0,0.20)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < arr.length; i++) {
          const px = arr[i].x * tile + tile / 2;
          const py = arr[i].y * tile + tile / 2;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }

    function drawAgents(agents) {
      const colors = ["#d32f2f", "#1976d2", "#388e3c", "#f57c00", "#7b1fa2", "#00838f"];
      let i = 0;
      for (const a of (agents || [])) {
        ctx.fillStyle = colors[i++ % colors.length];
        ctx.fillRect(a.x * tile, a.y * tile, tile, tile);
        ctx.fillStyle = "#000";
        ctx.font = "10px Arial";
        ctx.fillText(a.display_name || a.agent_id, a.x * tile + 2, a.y * tile - 2);

        // Intent overlay (latest trace summary)
        const intent = lastIntent[a.agent_id] || "";
        if (intent) {
          ctx.font = "9px Arial";
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          const txt = intent.length > 44 ? intent.slice(0, 44) + "…" : intent;
          const w = ctx.measureText(txt).width;
          const bx = a.x * tile;
          const by = a.y * tile - 22;
          ctx.fillRect(bx, by, Math.min(200, w + 6), 14);
          ctx.fillStyle = "#111";
          ctx.fillText(txt, bx + 3, by + 11);
        }
      }
    }

    resizeCanvas();
    canvas._didInitialResize = true;

    // --- Bulletin board ---
    const boardStatus = document.getElementById("boardStatus");
    const refreshPostsBtn = document.getElementById("refreshPostsBtn");
    const createPostBtn = document.getElementById("createPostBtn");
    const loadPostBtn = document.getElementById("loadPostBtn");
    const replyBtn = document.getElementById("replyBtn");
    const postsSelect = document.getElementById("postsSelect");
    const postDetails = document.getElementById("postDetails");

    // --- Jobs ---
    const jobsList = document.getElementById("jobsList");
    const jobTitle = document.getElementById("jobTitle");
    const jobBody = document.getElementById("jobBody");
    const jobReward = document.getElementById("jobReward");
    const jobReviewer = document.getElementById("jobReviewer");
    const jobCreateBtn = document.getElementById("jobCreateBtn");
    const jobsRefreshBtn = document.getElementById("jobsRefreshBtn");

    // --- Events ---
    const eventsList = document.getElementById("eventsList");
    const eventsStatus = document.getElementById("eventsStatus");
    const eventsRefreshBtn = document.getElementById("eventsRefreshBtn");
    const eventsShowPast = document.getElementById("eventsShowPast");
    const eventTitle = document.getElementById("eventTitle");
    const eventLocation = document.getElementById("eventLocation");
    const eventDesc = document.getElementById("eventDesc");
    const eventStartIn = document.getElementById("eventStartIn");
    const eventDuration = document.getElementById("eventDuration");
    const eventCreateBtn = document.getElementById("eventCreateBtn");

    async function fetchJson(path, opts) {
      const res = await fetch(BACKEND_HTTP + path, opts);
      const data = await res.json();
      if (!res.ok) throw new Error((data && data.error) ? data.error : ("HTTP " + res.status));
      return data;
    }

    let lastLoadedPostId = "";

    async function refreshPosts({autoLoadLatest = false} = {}) {
      try {
        const data = await fetchJson("/board/posts?limit=50");
        boardStatus.textContent = "ok";
        boardStatus.className = "pill ok";
        const posts = data.posts || [];
        postsSelect.innerHTML = "";
        let latestAgentChatPostId = "";
        for (const p of posts) {
          const opt = document.createElement("option");
          opt.value = p.post_id;
          opt.textContent = `[${p.status}] ${p.title} — ${p.author_type}:${p.author_id}`;
          postsSelect.appendChild(opt);
          if (!latestAgentChatPostId && Array.isArray(p.tags) && p.tags.includes("agent_chat")) {
            latestAgentChatPostId = p.post_id;
          }
        }
        if (posts.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "(no posts yet)";
          postsSelect.appendChild(opt);
        }

        if (autoLoadLatest) {
          // prefer latest agent_chat; otherwise keep current selection
          if (latestAgentChatPostId) {
            postsSelect.value = latestAgentChatPostId;
          }
          if (postsSelect.value) {
            await loadPost();
          }
        }
      } catch (e) {
        boardStatus.textContent = "error";
        boardStatus.className = "pill bad";
        log("[board] refresh error: " + e.message);
      }
    }

    async function createPost() {
      const title = document.getElementById("postTitle").value.trim();
      const body = document.getElementById("postBody").value.trim();
      const authorId = document.getElementById("postAuthor").value.trim();
      if (!title || !body) return alert("Please enter title + body.");
      try {
        await fetchJson("/board/posts", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({
            title, body,
            audience: "humans",
            tags: ["post"],
            author_type: "human",
            author_id: authorId || "human"
          })
        });
        log("[board] post created");
        await refreshPosts();
      } catch (e) {
        alert("Create post failed: " + e.message);
      }
    }

    async function loadPost() {
      const postId = postsSelect.value;
      if (!postId) return;
      try {
        const data = await fetchJson(`/board/posts/${postId}`);
        const p = data.post;
        const replies = data.replies || [];
        lastLoadedPostId = postId;
        let html = "";
        html += `<div><b>${p.title}</b></div>`;
        html += `<div style="color:#666;">${p.author_type}:${p.author_id} • ${new Date(p.created_at*1000).toLocaleString()} • status=${p.status}</div>`;
        html += `<div style="margin-top:6px; white-space:pre-wrap;">${p.body}</div>`;
        html += `<div style="margin-top:8px;"><b>Replies</b> (${replies.length})</div>`;
        if (replies.length === 0) {
          html += `<div style="color:#666;">(no replies yet)</div>`;
        } else {
          for (const r of replies) {
            html += `<div style="margin-top:6px; padding:6px; border-left:3px solid #4CAF50; background:#fafafa;">` +
              `<div style="color:#666; font-size:12px;">${r.author_type}:${r.author_id} • ${new Date(r.created_at*1000).toLocaleString()}</div>` +
              `<div style="white-space:pre-wrap;">${r.body}</div>` +
              `</div>`;
          }
        }
        postDetails.innerHTML = html;
      } catch (e) {
        alert("Load failed: " + e.message);
      }
    }

    async function replyToPost() {
      const postId = postsSelect.value;
      if (!postId) return alert("Select a post first.");
      const body = document.getElementById("replyBody").value.trim();
      const authorId = document.getElementById("replyAuthor").value.trim() || "human";
      if (!body) return alert("Enter reply text.");
      try {
        await fetchJson(`/board/posts/${postId}/replies`, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({ body, author_type: "human", author_id: authorId })
        });
        document.getElementById("replyBody").value = "";
        await loadPost();
      } catch (e) {
        alert("Reply failed: " + e.message);
      }
    }

    // Agents no longer write to the bulletin board; this is for humans/admin only.
    refreshPostsBtn.onclick = () => refreshPosts({autoLoadLatest: false});
    createPostBtn.onclick = createPost;
    loadPostBtn.onclick = loadPost;
    replyBtn.onclick = replyToPost;
    refreshPosts({autoLoadLatest: false});

    async function refreshTopic() {
      try {
        const data = await fetchJson("/chat/topic");
        topicStatus.textContent = data.topic ? data.topic : "(none)";
      } catch (e) {
        topicStatus.textContent = "topic error";
      }
    }
    refreshTopic();
    // Run info + archived runs list
    fetchRunInfo();
    refreshRuns();

    async function refreshBalances() {
      try {
        const data = await fetchJson("/economy/balances");
        const b = data.balances || {};
        latestBalances = b;
        const parts = Object.keys(b).sort().map(k => `${k}=${(b[k]||0).toFixed(1)} ai$`);
        balancesStatus.textContent = parts.length ? parts.join(" | ") : "(none)";
      } catch (e) {
        balancesStatus.textContent = "balances error";
      }
    }
    refreshBalances();
    setInterval(refreshBalances, 5000);

    async function refreshTrace() {
      try {
        const data = await fetchJson("/trace/recent?limit=50");
        const events = data.events || [];
        traceLog.innerHTML = "";
        for (const e of events) {
          const ts = new Date((e.created_at || Date.now()/1000) * 1000).toLocaleTimeString();
          trace(`[${ts}] ${e.agent_name} ${e.kind}: ${e.summary}`);
        }
      } catch (e) {
        trace("trace error: " + e.message);
      }
    }
    refreshTrace();

    function renderJob(j) {
      const wrap = document.createElement("div");
      wrap.style.borderTop = "1px solid #eee";
      wrap.style.padding = "8px 0";

      const head = document.createElement("div");
      head.innerHTML = `<b>[${j.status}]</b> ${j.title} <span style="color:#666;">(reward=${(j.reward||0).toFixed(1)} ai$)</span>`;
      wrap.appendChild(head);

      const meta = document.createElement("div");
      meta.style.color = "#666";
      meta.textContent = `id=${j.job_id} created_by=${j.created_by} claimed_by=${j.claimed_by||"-"} submitted_by=${j.submitted_by||"-"}`;
      wrap.appendChild(meta);

      if (j.status === "submitted") {
        const sub = document.createElement("div");
        const s = (j.submission || "");
        sub.textContent = `submission: ${s.slice(0, 200)}${s.length > 200 ? "…" : ""}`;
        wrap.appendChild(sub);

        const opts = document.createElement("div");
        opts.style.display = "flex";
        opts.style.gap = "8px";
        opts.style.marginTop = "6px";
        opts.style.alignItems = "center";

        const payout = document.createElement("input");
        payout.type = "number";
        payout.min = "0";
        payout.step = "1";
        payout.value = String(j.reward || 0);
        payout.style.width = "110px";
        payout.title = "payout (<= reward)";

        const penalty = document.createElement("input");
        penalty.type = "number";
        penalty.min = "0";
        penalty.step = "1";
        penalty.value = "0";
        penalty.style.width = "110px";
        penalty.title = "penalty (ai$ removed)";

        opts.appendChild(payout);
        opts.appendChild(penalty);
        wrap.appendChild(opts);

        const btnRow = document.createElement("div");
        btnRow.style.display = "flex";
        btnRow.style.gap = "8px";
        btnRow.style.marginTop = "6px";

        const okBtn = document.createElement("button");
        okBtn.textContent = "Approve + award";
        okBtn.onclick = async () => {
          await fetchJson(`/jobs/${j.job_id}/review`, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              approved:true,
              reviewed_by: jobReviewer.value || "human",
              note:"ok",
              payout: parseFloat(payout.value || String(j.reward || 0)),
              penalty: parseFloat(penalty.value || "0")
            })
          });
          await refreshJobs();
          await refreshBalances();
        };

        const noBtn = document.createElement("button");
        noBtn.textContent = "Reject";
        noBtn.onclick = async () => {
          await fetchJson(`/jobs/${j.job_id}/review`, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              approved:false,
              reviewed_by: jobReviewer.value || "human",
              note:"needs improvement",
              penalty: parseFloat(penalty.value || "0")
            })
          });
          await refreshJobs();
        };

        btnRow.appendChild(okBtn);
        btnRow.appendChild(noBtn);
        wrap.appendChild(btnRow);
      }

      return wrap;
    }

    async function refreshJobs() {
      try {
        const data = await fetchJson("/jobs?limit=50");
        const jobs = data.jobs || [];
        jobsList.innerHTML = "";
        for (const j of jobs) jobsList.appendChild(renderJob(j));
      } catch (e) {
        jobsList.textContent = "jobs error: " + e.message;
      }
    }
    refreshJobs();
    setInterval(refreshJobs, 5000);

    jobsRefreshBtn.onclick = refreshJobs;
    jobCreateBtn.onclick = async () => {
      const title = (jobTitle.value || "").trim();
      const body = (jobBody.value || "").trim();
      const reward = parseFloat(jobReward.value || "10");
      if (!title || !body || !isFinite(reward) || reward <= 0) {
        alert("Enter title, body, and positive reward.");
        return;
      }
      await fetchJson("/jobs/create", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({title, body, reward, created_by: jobReviewer.value || "human"})
      });
      jobTitle.value = "";
      jobBody.value = "";
      await refreshJobs();
    };

    function totalMinutes(day, minute) {
      return (day|0) * 1440 + (minute|0);
    }

    function computeEventPhase(e, world) {
      if (!world || typeof world.day === "undefined" || typeof world.minute_of_day === "undefined") {
        return (e.status || "scheduled");
      }
      const now = totalMinutes(world.day, world.minute_of_day);
      const start = totalMinutes(e.start_day, e.start_minute);
      const end = start + Math.max(1, (e.duration_min|0));
      if (now < start) return "scheduled";
      if (now <= end) return "active";
      return "past";
    }

    function renderEvent(e) {
      const wrap = document.createElement("div");
      wrap.style.borderTop = "1px solid #eee";
      wrap.style.padding = "8px 0";
      const when = (typeof e.start_day !== "undefined") ? `day=${e.start_day} ${String(Math.floor(e.start_minute/60)).padStart(2,'0')}:${String(e.start_minute%60).padStart(2,'0')}` : "";
      const phase = computeEventPhase(e, latestWorld);
      let countdown = "";
      if (latestWorld && typeof latestWorld.day !== "undefined" && typeof latestWorld.minute_of_day !== "undefined") {
        const now = totalMinutes(latestWorld.day, latestWorld.minute_of_day);
        const start = totalMinutes(e.start_day, e.start_minute);
        const delta = start - now;
        if (phase === "scheduled") countdown = ` • starts in ${delta}m`;
        if (phase === "active") countdown = ` • started ${Math.abs(delta)}m ago`;
      }
      wrap.innerHTML =
        `<div><b>[${phase}]</b> ${e.title}</div>` +
        `<div style="color:#666;">${when} @ ${e.location_id}${countdown} • by ${e.created_by} • dur=${e.duration_min}m</div>` +
        (e.description ? `<div>${e.description}</div>` : "");
      const inv = (e.invites || []).map(i => `${i.from_agent_id}->${i.to_agent_id}`).join(", ");
      if (inv) {
        const d = document.createElement("div");
        d.style.color = "#666";
        d.textContent = `invites: ${inv}`;
        wrap.appendChild(d);
      }
      const rsvps = e.rsvps || {};
      const ks = Object.keys(rsvps);
      if (ks.length) {
        const d = document.createElement("div");
        d.style.color = "#666";
        d.textContent = `rsvps: ` + ks.map(k => `${k}=${rsvps[k]}`).join(", ");
        wrap.appendChild(d);
      }
      return wrap;
    }

    async function refreshEvents() {
      try {
        const showPast = !!(eventsShowPast && eventsShowPast.checked);
        // upcoming_only=true includes events that are upcoming OR currently ongoing (backend logic).
        const data = await fetchJson(`/events?upcoming_only=${showPast ? "false" : "true"}&limit=50`);
        const evs = data.events || [];
        eventsList.innerHTML = "";
        for (const e of evs) eventsList.appendChild(renderEvent(e));
        eventsStatus.textContent = "ok";
        eventsStatus.className = "pill ok";
      } catch (e) {
        eventsStatus.textContent = "error";
        eventsStatus.className = "pill bad";
      }
    }
    eventsRefreshBtn.onclick = refreshEvents;
    if (eventsShowPast) eventsShowPast.onchange = refreshEvents;
    refreshEvents();

    eventCreateBtn.onclick = async () => {
      if (!latestWorld) return alert("Wait for world state.");
      const title = (eventTitle.value||"").trim();
      if (!title) return alert("Title required");
      const startIn = parseInt(eventStartIn.value||"60", 10);
      const dur = parseInt(eventDuration.value||"60", 10);
      const day = latestWorld.day || 0;
      const startMinute = (latestWorld.minute_of_day || 0) + Math.max(5, startIn);
      await fetchJson("/events/create", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          title,
          description: (eventDesc.value||"").trim(),
          location_id: eventLocation.value,
          start_day: day + Math.floor(startMinute/1440),
          start_minute: startMinute % 1440,
          duration_min: Math.max(10, dur),
          created_by: (jobReviewer && jobReviewer.value) ? jobReviewer.value : "human"
        })
      });
      eventTitle.value = "";
      eventDesc.value = "";
      await refreshEvents();
    };

    // --- WebSocket world ---
    function buildOccupancy(world) {
      const occ = {}; // "x,y" -> {agents:[], landmarks:[]}
      if (!world) return occ;
      for (const lm of (world.landmarks || [])) {
        const k = `${lm.x},${lm.y}`;
        if (!occ[k]) occ[k] = {agents: [], landmarks: []};
        occ[k].landmarks.push(lm);
      }
      for (const a of (world.agents || [])) {
        const k = `${a.x},${a.y}`;
        if (!occ[k]) occ[k] = {agents: [], landmarks: []};
        occ[k].agents.push(a);
      }
      return occ;
    }

    function drawBadge(x, y, count) {
      // small badge in top-right corner
      const cx = x * tile + tile - 5;
      const cy = y * tile + 5;
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "9px Arial";
      ctx.fillText(String(count), cx - 3, cy + 3);
    }

    function drawOverlaps(occ) {
      for (const k of Object.keys(occ)) {
        const parts = k.split(",");
        const x = parseInt(parts[0], 10);
        const y = parseInt(parts[1], 10);
        const e = occ[k];
        const total = (e.agents?.length || 0) + (e.landmarks?.length || 0);
        if (total > 1) drawBadge(x, y, total);
      }
    }

    function connect() {
      log("[ws] connecting to " + BACKEND_WS);
      const ws = new WebSocket(BACKEND_WS);

      ws.onopen = () => {
        wsStatus.textContent = "connected";
        wsStatus.className = "pill ok";
        log("[ws] connected");
        setInterval(() => { try { ws.send("ping"); } catch (e) {} }, 10000);
      };

      ws.onclose = () => {
        wsStatus.textContent = "disconnected";
        wsStatus.className = "pill bad";
        log("[ws] closed; reconnecting in 1s...");
        setTimeout(connect, 1000);
      };

      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === "world_state") {
            const data = msg.data;
            latestWorld = data;
            for (const a of (data.agents || [])) pushTrail(a);
            // Ensure canvas is sized to current viewport before rendering
            if (!canvas._didInitialResize) { resizeCanvas(); canvas._didInitialResize = true; }
            drawGrid();
            const occ = buildOccupancy(data);
            drawTrails(data.agents);
            drawLandmarks(data.landmarks);
            drawAgentsGrouped(data.agents, occ);
            drawOverlaps(occ);
            worldStatus.textContent = "tick=" + data.tick + " agents=" + (data.agents || []).length;
            if (typeof data.day !== "undefined" && typeof data.minute_of_day !== "undefined") {
              timeStatus.textContent = fmtTime(data.day, data.minute_of_day);
            }
          } else if (msg.type === "chat") {
            const c = msg.data;
            const ts = new Date((c.created_at || Date.now()/1000) * 1000).toLocaleTimeString();
            log(`[chat ${ts}] ${c.sender_name} (${c.sender_id}): ${c.text}`);
          } else if (msg.type === "topic") {
            const t = msg.data;
            if (t && t.topic) topicStatus.textContent = t.topic;
          } else if (msg.type === "balances") {
            try {
              const b = (msg.data && msg.data.balances) ? msg.data.balances : {};
              latestBalances = b;
              const parts = Object.keys(b).sort().map(k => `${k}=${(b[k]||0).toFixed(1)} ai$`);
              balancesStatus.textContent = parts.length ? parts.join(" | ") : "(none)";
            } catch (e) {}
          } else if (msg.type === "jobs") {
            refreshJobs();
          } else if (msg.type === "events") {
            refreshEvents();
          } else if (msg.type === "trace") {
            const e = msg.data;
            const ts = new Date((e.created_at || Date.now()/1000) * 1000).toLocaleTimeString();
            trace(`[${ts}] ${e.agent_name} ${e.kind}: ${e.summary}`);
            if (e && e.agent_id && e.summary) {
              lastIntent[e.agent_id] = `${e.kind}: ${e.summary}`;
            }
          }
        } catch (e) {}
      };
    }

    connect();

    function drawAgentsGrouped(agents, occ) {
      // draw agents, splitting tiles when multiple agents share a tile
      const colors = ["#d32f2f", "#1976d2", "#388e3c", "#f57c00", "#7b1fa2", "#00838f"];
      const byTile = {};
      for (const a of (agents || [])) {
        const k = `${a.x},${a.y}`;
        (byTile[k] = byTile[k] || []).push(a);
      }

      let colorIdx = 0;
      for (const k of Object.keys(byTile)) {
        const list = byTile[k];
        const [xs, ys] = k.split(",");
        const x = parseInt(xs, 10), y = parseInt(ys, 10);

        // reserve base tile; landmarks already drawn
        if (list.length === 1) {
          const a = list[0];
          ctx.fillStyle = colors[colorIdx++ % colors.length];
          ctx.fillRect(x * tile, y * tile, tile, tile);
          drawAgentLabel(a);
        } else {
          // split into 2x2 mini-squares
          const mini = Math.floor(tile / 2);
          const slots = [
            {dx: 0, dy: 0},
            {dx: mini, dy: 0},
            {dx: 0, dy: mini},
            {dx: mini, dy: mini},
          ];
          for (let i = 0; i < Math.min(list.length, 4); i++) {
            const a = list[i];
            const s = slots[i];
            ctx.fillStyle = colors[colorIdx++ % colors.length];
            ctx.fillRect(x * tile + s.dx, y * tile + s.dy, mini, mini);
          }
          // label the first agent; hover tooltip gives full detail
          drawAgentLabel(list[0]);
        }
      }
    }

    function drawAgentLabel(a) {
      ctx.fillStyle = "#000";
      ctx.font = "10px Arial";
      ctx.fillText(a.display_name || a.agent_id, a.x * tile + 2, a.y * tile - 2);

      const intent = lastIntent[a.agent_id] || "";
      if (intent) {
        ctx.font = "9px Arial";
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        const txt = intent.length > 44 ? intent.slice(0, 44) + "…" : intent;
        const w = ctx.measureText(txt).width;
        const bx = a.x * tile;
        const by = a.y * tile - 22;
        ctx.fillRect(bx, by, Math.min(200, w + 6), 14);
        ctx.fillStyle = "#111";
        ctx.fillText(txt, bx + 3, by + 11);
      }
    }

    // Hover tooltip for tile details
    canvas.addEventListener("mousemove", (ev) => {
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const x = Math.floor(mx / tile);
      const y = Math.floor(my / tile);
      const key = `${x},${y}`;
      if (key === lastHoverKey && tooltip.style.display === "block") {
        tooltip.style.left = (ev.clientX + 12) + "px";
        tooltip.style.top = (ev.clientY + 12) + "px";
        return;
      }
      lastHoverKey = key;
      const occ = buildOccupancy(latestWorld);
      const entry = occ[key];
      if (!entry) {
        tooltip.style.display = "none";
        return;
      }

      let text = `tile (${x},${y})\n`;
      if (entry.landmarks && entry.landmarks.length) {
        text += `landmarks:\n`;
        for (const lm of entry.landmarks) {
          text += `- ${lm.id} (${lm.type})\n`;
        }
      }
      if (entry.agents && entry.agents.length) {
        text += `agents:\n`;
        for (const a of entry.agents) {
          const bal = (latestBalances && (a.agent_id in latestBalances)) ? latestBalances[a.agent_id] : null;
          const intent = lastIntent[a.agent_id] || "";
          text += `- ${a.display_name || a.agent_id} id=${a.agent_id} bal=${bal === null ? "?" : (bal || 0).toFixed(1)}\n`;
          if (intent) text += `  intent: ${intent}\n`;
        }
      }
      tooltip.textContent = text.trimEnd();
      tooltip.style.display = "block";
      tooltip.style.left = (ev.clientX + 12) + "px";
      tooltip.style.top = (ev.clientY + 12) + "px";
    });

    canvas.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
      lastHoverKey = "";
    });
  </script>
</body>
</html>

